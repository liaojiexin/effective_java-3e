覆盖equals时总要覆盖hashCode
如果不这样做的话，就会违反hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常的运行，这类集合包括HashMap和HashSet

1.在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对同个对象的多次调用，hashCode方法都
必须始终返回同个值。在一个应用程序与另一个程序的执行过程中，执行hashCode方法所返回的值可以不一致。
2.如果两个对象根据equals(Object)方法是相等的，那么调用这两个对象中的hashCode方法都必须产生同样的整数结果。
3.如果两个对象根据equals(Object)方法比较是不相等的，那么调用这两个对象中的hashCode方法，则不一定要求hashCode方法必须
产生不同的结果。但是程序员应该知道，给不相等的对象产生截然不同的结果，有可能提高散列表的性能（散列表利先比较hashCode来提高查找性能
，如果hashCode不相等就可以直接排除，反之再用equals进行下一步比较，所以一般为不同的对象产生不同的散列码）。

没有覆盖hashCode会违反上面第二条约定，相等的对象必须具有相等的散列码。

例子：PhoneNumber  理想情况下，散列函数应该把集合中不相等的实例均匀地分不到所有可能的int值上。