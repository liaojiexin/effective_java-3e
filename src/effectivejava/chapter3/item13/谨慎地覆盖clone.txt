谨慎地覆盖clone
super.clone调用父级Object的clone方法，为浅拷贝，即新旧对象是同一个内存地址，拷贝的对象会随原对象内容的改变而改变。

clone方法的通用约定是非常弱的，以下是Object规范中复制出来的：
创建并返回此对象的副本。 “复制（copy）”的确切含义可能取决于对象的类。 一般意图是，对于任何对象 x，表
达式 x.clone() != x 返回 true，并且 x.clone().getClass() == x.getClass() 也返回 true，但它们不是
绝对的要求，但通常情况下， x.clone().equals(x) 返回 true，当然这个要求也不是绝对的。
根据约定，这个方法返回的对象应该通过调用 super.clone 方法获得的。 如果一个类和它的所有父类
（Object 除外）都遵守这个约定，情况就是如此， x.clone().getClass() == x.getClass() 。
根据约定，返回的对象应该独立于被克隆的对象。 为了实现这种独立性，在返回对象之前，可能需要修改由
super.clone 返回的对象的一个或多个属性。

PhoneNumber类 浅拷贝，不可变的类永远都不应该提供clone方法。
Stack类  如果对象中包含的域引用了可变的对象，使用上述简单的clone实现可能会导致灾难性的后果。