谨慎地覆盖clone
super.clone调用父级Object的clone方法，为浅拷贝，即新旧对象是同一个内存地址，拷贝的对象会随原对象内容的改变而改变(基本数据类型除外)。

clone方法的通用约定是非常弱的，以下是Object规范中复制出来的：
创建并返回此对象的副本。 “复制（copy）”的确切含义可能取决于对象的类。 一般意图是，对于任何对象 x，表
达式 x.clone() != x 返回 true，并且 x.clone().getClass() == x.getClass() 也返回 true，但它们不是
绝对的要求，但通常情况下， x.clone().equals(x) 返回 true，当然这个要求也不是绝对的。
根据约定，这个方法返回的对象应该通过调用 super.clone 方法获得的。 如果一个类和它的所有父类
（Object 除外）都遵守这个约定，情况就是如此， x.clone().getClass() == x.getClass() 。
根据约定，返回的对象应该独立于被克隆的对象。 为了实现这种独立性，在返回对象之前，可能需要修改由
super.clone 返回的对象的一个或多个属性。

PhoneNumber类 浅拷贝，不可变的类永远都不应该提供clone方法。
Stack类  如果对象中包含的域引用了可变的对象，使用上述简单的clone实现可能会导致灾难性的后果。

了解深拷贝和浅拷贝

    回顾一下，实现 Cloneable 的所有类应该重写公共 clone 方法，而这个方法的返回类型是类本身。 这个方法应该
首先调用 super.clone，然后修复任何需要修复的属性。 通常，这意味着复制任何包含内部“深层结构”的可变对象，
并用指向新对象的引用来代替原来指向这些对象的引用。虽然这些内部拷贝通常可以通过递归调用 clone 来实现，但
这并不总是最好的方法。 如果类只包含基本类型或对不可变对象的引用，那么很可能是没有属性需要修复的情况。
    这个规则也有例外。 例如，表示序列号或其他唯一 ID 的属性即使是基本类型的或不可变的，也需要被修正。
这么复杂是否真的有必要？很少。 如果你继承一个已经实现了 Cloneable 接口的类，你别无选择，只能实现一个
行为良好的 clone 方法。 否则，通常你最好提供另一种对象复制方法。 对象复制更好的方法是提供一个复制构造方
法或复制工厂。
    考虑到与 Cloneable 接口相关的所有问题，新的接口不应该继承它，新的可扩展类不应该实现它。 虽然实现
Cloneable 接口对于 final 类没有什么危害，但应该将其视为性能优化的角度，仅在极少数情况下才是合理的（条目
67）。 通常，复制功能最好由构造方法或工厂提供。 这个规则的一个明显的例外是数组，它最好用 clone 方法复
制。